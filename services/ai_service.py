# services/ai_service.py
# بخش ۱ از ۴: تنظیمات، انواع داده و ساختار اصلی
# سرویس هوش مصنوعی چندمدله با OpenRouter.ai
# نسخه نهایی و حرفه‌ای - ژانویه ۲۰۲۵

"""
این سرویس از OpenRouter.ai استفاده می‌کند که دسترسی به مدل‌های زیر را فراهم می‌کند:
- OpenAI GPT-4o, GPT-4-Turbo, GPT-3.5-Turbo
- Anthropic Claude 3.5 Sonnet, Claude 3 Opus
- Google Gemini Pro, Gemini Flash
- xAI Grok
- Meta Llama 3.1
- Mistral, Mixtral
- و ده‌ها مدل دیگر

ویژگی‌های کلیدی:
1. پشتیبانی از چندین مدل با یک API Key
2. سیستم Fallback چندلایه (اگر یک مدل fail شد، مدل بعدی)
3. کش هوشمند برای کاهش هزینه و سرعت بیشتر
4. اطلاع‌رسانی به ادمین در صورت بروز مشکل
5. پاسخ‌های آماده برای وقتی که همه API ها fail شوند
6. لاگینگ کامل برای دیباگ
"""

import httpx
import asyncio
import random
import hashlib
import json
import time
from typing import Optional, Dict, List, Tuple, Any, Callable
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from pathlib import Path

# ایمپورت از پروژه
from config import settings, logger


# ═══════════════════════════════════════════════════════════════════════════════
# ۱. تنظیمات OpenRouter و مدل‌ها
# ═══════════════════════════════════════════════════════════════════════════════

# آدرس API اصلی OpenRouter (سازگار با فرمت OpenAI)
OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1/chat/completions"


def get_openrouter_headers(api_key: str) -> Dict[str, str]:
    """ساخت هدرهای مورد نیاز برای OpenRouter"""
    return {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://t.me/SmartStudentBot",
        "X-Title": "SmartStudentBot Perugia",
    }


# ═══════════════════════════════════════════════════════════════════════════════
# ۲. تعریف مدل‌های موجود با اولویت‌بندی
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class AIModel:
    """کلاس نگهداری اطلاعات هر مدل AI"""
    
    # شناسه مدل در OpenRouter
    model_id: str
    
    # نام نمایشی برای کاربر
    display_name: str
    
    # شرکت سازنده
    provider: str
    
    # اولویت (عدد کمتر = اولویت بالاتر)
    priority: int
    
    # حداکثر توکن خروجی
    max_tokens: int = 4096
    
    # آیا برای چت مناسب است؟
    supports_chat: bool = True
    
    # آیا برای ترجمه مناسب است؟
    supports_translation: bool = True
    
    # آیا برای خلاصه‌سازی مناسب است؟
    supports_summarization: bool = True
    
    # هزینه تقریبی (دلار به ازای هر میلیون توکن)
    cost_per_million: float = 0.0
    
    # آیا فعال است؟
    is_active: bool = True


# لیست کامل مدل‌های پشتیبانی شده با اولویت‌بندی
AVAILABLE_MODELS: Dict[str, AIModel] = {
    
    # ═══════════════════════════════════════════════════════
    # OpenAI Models (اولویت ۱-۴)
    # ═══════════════════════════════════════════════════════
    
    "gpt-4o": AIModel(
        model_id="openai/gpt-4o",
        display_name="GPT-4o",
        provider="OpenAI",
        priority=1,
        max_tokens=4096,
        cost_per_million=5.0,
    ),
    
    "gpt-4o-mini": AIModel(
        model_id="openai/gpt-4o-mini",
        display_name="GPT-4o Mini",
        provider="OpenAI",
        priority=2,
        max_tokens=4096,
        cost_per_million=0.15,
    ),
    
    "gpt-4-turbo": AIModel(
        model_id="openai/gpt-4-turbo",
        display_name="GPT-4 Turbo",
        provider="OpenAI",
        priority=3,
        max_tokens=4096,
        cost_per_million=10.0,
    ),
    
    "gpt-3.5-turbo": AIModel(
        model_id="openai/gpt-3.5-turbo",
        display_name="GPT-3.5 Turbo",
        provider="OpenAI",
        priority=4,
        max_tokens=4096,
        cost_per_million=0.5,
    ),
    
    # ═══════════════════════════════════════════════════════
    # Anthropic Claude Models (اولویت ۵-۷)
    # ═══════════════════════════════════════════════════════
    
    "claude-3.5-sonnet": AIModel(
        model_id="anthropic/claude-3.5-sonnet",
        display_name="Claude 3.5 Sonnet",
        provider="Anthropic",
        priority=5,
        max_tokens=4096,
        cost_per_million=3.0,
    ),
    
    "claude-3-haiku": AIModel(
        model_id="anthropic/claude-3-haiku",
        display_name="Claude 3 Haiku",
        provider="Anthropic",
        priority=6,
        max_tokens=4096,
        cost_per_million=0.25,
    ),
    
    "claude-3-opus": AIModel(
        model_id="anthropic/claude-3-opus",
        display_name="Claude 3 Opus",
        provider="Anthropic",
        priority=7,
        max_tokens=4096,
        cost_per_million=15.0,
    ),
    
    # ═══════════════════════════════════════════════════════
    # Google Gemini Models (اولویت ۸-۹)
    # ═══════════════════════════════════════════════════════
    
    "gemini-pro": AIModel(
        model_id="google/gemini-pro-1.5",
        display_name="Gemini Pro 1.5",
        provider="Google",
        priority=8,
        max_tokens=4096,
        cost_per_million=1.25,
    ),
    
    "gemini-flash": AIModel(
        model_id="google/gemini-flash-1.5",
        display_name="Gemini Flash 1.5",
        provider="Google",
        priority=9,
        max_tokens=4096,
        cost_per_million=0.075,
    ),
    
    # ═══════════════════════════════════════════════════════
    # xAI Grok (اولویت ۱۰)
    # ═══════════════════════════════════════════════════════
    
    "grok": AIModel(
        model_id="x-ai/grok-beta",
        display_name="Grok",
        provider="xAI",
        priority=10,
        max_tokens=4096,
        cost_per_million=5.0,
    ),
    
    # ═══════════════════════════════════════════════════════
    # Meta Llama (اولویت ۱۱-۱۲)
    # ═══════════════════════════════════════════════════════
    
    "llama-3.1-70b": AIModel(
        model_id="meta-llama/llama-3.1-70b-instruct",
        display_name="Llama 3.1 70B",
        provider="Meta",
        priority=11,
        max_tokens=4096,
        cost_per_million=0.9,
    ),
    
    "llama-3.1-8b": AIModel(
        model_id="meta-llama/llama-3.1-8b-instruct",
        display_name="Llama 3.1 8B",
        provider="Meta",
        priority=12,
        max_tokens=4096,
        cost_per_million=0.06,
    ),
    
    # ═══════════════════════════════════════════════════════
    # Mistral (اولویت ۱۳-۱۴)
    # ═══════════════════════════════════════════════════════
    
    "mistral-large": AIModel(
        model_id="mistralai/mistral-large",
        display_name="Mistral Large",
        provider="Mistral",
        priority=13,
        max_tokens=4096,
        cost_per_million=3.0,
    ),
    
    "mistral-7b": AIModel(
        model_id="mistralai/mistral-7b-instruct",
        display_name="Mistral 7B",
        provider="Mistral",
        priority=14,
        max_tokens=4096,
        cost_per_million=0.07,
    ),
    
    # ═══════════════════════════════════════════════════════
    # مدل‌های رایگان برای Fallback نهایی (اولویت ۱۵+)
    # ═══════════════════════════════════════════════════════
    
    "phi-3-mini": AIModel(
        model_id="microsoft/phi-3-mini-128k-instruct",
        display_name="Phi-3 Mini",
        provider="Microsoft",
        priority=15,
        max_tokens=4096,
        cost_per_million=0.1,
    ),
    
    "gemma-2-9b": AIModel(
        model_id="google/gemma-2-9b-it",
        display_name="Gemma 2 9B",
        provider="Google",
        priority=16,
        max_tokens=4096,
        cost_per_million=0.08,
    ),
}


# ═══════════════════════════════════════════════════════════════════════════════
# ۳. تنظیمات پیش‌فرض مدل‌ها برای هر نوع کار
# ═══════════════════════════════════════════════════════════════════════════════

# ترتیب مدل‌ها برای چت (از بهترین به ارزان‌ترین)
CHAT_MODEL_PRIORITY: List[str] = [
    "gpt-4o-mini",
    "claude-3-haiku",
    "gemini-flash",
    "gpt-3.5-turbo",
    "llama-3.1-8b",
    "mistral-7b",
    "phi-3-mini",
]

# ترتیب مدل‌ها برای ترجمه (دقت بالا)
TRANSLATION_MODEL_PRIORITY: List[str] = [
    "gpt-4o",
    "claude-3.5-sonnet",
    "gpt-4o-mini",
    "gemini-pro",
    "gpt-3.5-turbo",
]

# ترتیب مدل‌ها برای خلاصه‌سازی
SUMMARIZATION_MODEL_PRIORITY: List[str] = [
    "claude-3.5-sonnet",
    "gpt-4o-mini",
    "gemini-flash",
    "gpt-3.5-turbo",
]


# ═══════════════════════════════════════════════════════════════════════════════
# ۴. انواع داده و ساختارهای کمکی
# ═══════════════════════════════════════════════════════════════════════════════

class AIStatus(Enum):
    """وضعیت کلی سرویس AI"""
    ONLINE = "online"
    DEGRADED = "degraded"
    LIMITED = "limited"
    OFFLINE = "offline"


class TaskType(Enum):
    """نوع کار درخواستی"""
    CHAT = "chat"
    TRANSLATION = "translation"
    SUMMARIZATION = "summarization"
    ITALIAN_HELP = "italian_help"
    SUPPORT = "support"


@dataclass
class APIUsageStats:
    """آمار استفاده از API"""
    
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    fallback_used: int = 0
    
    last_error: Optional[str] = None
    last_error_time: Optional[datetime] = None
    last_error_model: Optional[str] = None
    
    total_tokens_used: int = 0
    requests_per_model: Dict[str, int] = field(default_factory=dict)
    last_successful_request: Optional[datetime] = None


@dataclass
class CacheEntry:
    """یک ورودی در کش"""
    
    response: str
    timestamp: datetime
    source: str
    model_used: Optional[str] = None
    hit_count: int = 0


@dataclass
class AIResponse:
    """ساختار پاسخ نهایی AI"""
    
    text: str
    is_ai_generated: bool
    model_used: Optional[str] = None
    provider: Optional[str] = None
    from_cache: bool = False
    is_fallback: bool = False
    processing_time_ms: int = 0
    error: Optional[str] = None


# ═══════════════════════════════════════════════════════════════════════════════
# ۵. تنظیمات کش
# ═══════════════════════════════════════════════════════════════════════════════

CACHE_TTL_HOURS: int = 4
MAX_CACHE_SIZE: int = 1000
MIN_MESSAGE_LENGTH_FOR_CACHE: int = 10


# ═══════════════════════════════════════════════════════════════════════════════
# ۶. تنظیمات Retry و Timeout
# ═══════════════════════════════════════════════════════════════════════════════

MAX_RETRIES_PER_MODEL: int = 2
RETRY_DELAY_SECONDS: float = 1.0
REQUEST_TIMEOUT_SECONDS: float = 30.0
CONNECTION_TIMEOUT_SECONDS: float = 10.0


# ═══════════════════════════════════════════════════════════════════════════════
# ۷. پرامپت‌های سیستم برای هر نوع کار
# ═══════════════════════════════════════════════════════════════════════════════

SYSTEM_PROMPTS: Dict[str, str] = {
    
    "student_assistant": """تو یک دستیار هوشمند و دوستانه برای دانشجویان ایرانی در شهر پروجای ایتالیا هستی.

نام تو «دستیار پروجا» است.

وظایف تو:
- پاسخ به سوالات درباره تحصیل در ایتالیا
- راهنمایی درباره ویزا، پرمسو، و مسائل اداری
- کمک در مورد هزینه‌ها، بورسیه، و ISEE
- راهنمایی درباره زندگی در پروجا و ایتالیا
- کمک در یادگیری زبان ایتالیایی

قوانین پاسخ‌دهی:
1. همیشه به زبان فارسی پاسخ بده
2. مختصر، دقیق و کاربردی باش
3. اگر مطمئن نیستی، صادقانه بگو که نمی‌دانی
4. از ایموجی مناسب استفاده کن
5. اطلاعات قدیمی نده - اگر چیزی ممکنه تغییر کرده باشه، به کاربر بگو چک کنه
6. لحن دوستانه و صمیمی داشته باش""",

    "translator": """تو یک مترجم حرفه‌ای هستی که بین زبان‌های ایتالیایی، انگلیسی و فارسی ترجمه می‌کنی.

قوانین ترجمه:
1. ترجمه باید طبیعی و روان باشد، نه کلمه به کلمه
2. اصطلاحات تخصصی را توضیح بده
3. اگر کلمه‌ای معادل دقیق ندارد، توضیح بده
4. تلفظ کلمات ایتالیایی را با فینگلیش بنویس
5. برای اصطلاحات اداری ایتالیا، معادل فارسی و توضیح بده""",

    "italian_teacher": """تو یک معلم زبان ایتالیایی هستی که به فارسی تدریس می‌کنی.

روش تدریس:
1. توضیحات ساده و قابل فهم بده
2. مثال‌های کاربردی و روزمره بزن
3. تلفظ را با فینگلیش بنویس (مثلاً: Buongiorno = بوئون‌جورنو)
4. نکات گرامری مهم را توضیح بده
5. اشتباهات رایج ایرانی‌ها را گوشزد کن
6. جملات مفید برای زندگی در ایتالیا یاد بده""",

    "support_agent": """تو یک پشتیبان حرفه‌ای و صبور هستی.

وظایف:
1. به سوالات کاربران با دقت پاسخ بده
2. اگر نمی‌توانی کمک کنی، صادقانه بگو و به ادمین ارجاع بده
3. همیشه مودب و صبور باش
4. سعی کن مشکل را درک کنی قبل از پاسخ دادن

در پایان پاسخ، اگر فکر می‌کنی کاربر نیاز به کمک بیشتر دارد، بگو که می‌تواند تیکت بزند.""",

    "summarizer": """تو یک متخصص خلاصه‌سازی هستی.

قوانین خلاصه‌سازی:
1. نکات کلیدی را استخراج کن
2. خلاصه باید حداکثر ۳۰٪ متن اصلی باشد
3. ترتیب منطقی را حفظ کن
4. جزئیات غیرضروری را حذف کن
5. به زبان فارسی خلاصه کن""",
}


# ═══════════════════════════════════════════════════════════════════════════════
# ۸. مسیرها و فایل‌ها
# ═══════════════════════════════════════════════════════════════════════════════

BASE_DIR = Path(__file__).parent.parent
DATA_DIR = BASE_DIR / "data"
STATS_FILE = DATA_DIR / "ai_stats.json"
CACHE_FILE = DATA_DIR / "ai_cache.json"


# ═══════════════════════════════════════════════════════════════════════════════
# ۹. توصیه‌های آب‌وهوا
# ═══════════════════════════════════════════════════════════════════════════════

WEATHER_ADVICE: Dict[str, str] = {
    "hot": "☀️ <b>هوا گرمه!</b> آب زیاد بخور، کرم ضدآفتاب بزن و کلاه یادت نره.",
    "warm": "🌤 <b>هوا گرم و دلپذیره!</b> روز خوبی برای گشت‌وگذار در پروجاست.",
    "mild": "🌡 <b>هوا معتدله!</b> یه ژاکت سبک همراه داشته باش.",
    "cool": "🍂 <b>هوا خنکه!</b> کاپشن سبک یا سویشرت ببر.",
    "cold": "❄️ <b>هوا سرده!</b> لباس گرم، کلاه و شال‌گردن یادت نره.",
    "freezing": "🥶 <b>یخبندانه!</b> لباس‌های خیلی گرم بپوش. دستکش هم ببر.",
    "rainy": "🌧 <b>بارونیه!</b> چتر ببر و کفش ضدآب بپوش.",
    "stormy": "⛈ <b>طوفانیه!</b> تا می‌تونی بیرون نرو.",
    "snowy": "🌨 <b>برفیه!</b> لباس گرم و کفش مناسب برف بپوش.",
    "windy": "💨 <b>باد شدیده!</b> کاپشن بادگیر ببر.",
    "foggy": "🌫 <b>مه‌آلوده!</b> موقع رانندگی احتیاط کن.",
    "cloudy": "☁️ <b>ابریه!</b> احتمال باران هست، چتر همراه داشته باش.",
    "nice": "🌈 <b>هوا عالیه!</b> برو بیرون و از پروجای زیبا لذت ببر!",
}


# ═══════════════════════════════════════════════════════════════════════════════
# پایان بخش ۱ - ادامه در بخش ۲
# ═══════════════════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════════════════
# ۱۰. دیتابیس پاسخ‌های آماده (Fallback Responses)
# ═══════════════════════════════════════════════════════════════════════════════

FALLBACK_RESPONSES: Dict[str, List[str]] = {

    # ═══════════════════════════════════════════════════════
    # احوالپرسی و سلام
    # ═══════════════════════════════════════════════════════

    "سلام": [
        "سلام! 👋 من دستیار هوشمند پروجا هستم. چطور می‌تونم کمکت کنم؟",
        "درود بر شما! 🎓 خوشحالم که پیام دادید. سوالتون رو بپرسید!",
        "سلام دوست عزیز! 🌟 آماده‌ام کمکت کنم. چه سوالی داری؟",
    ],

    "خوبی": [
        "ممنون از لطفت! 😊 من یه ربات هستم ولی خوشحالم که حالمو پرسیدی. تو چطوری؟",
        "عالیم! 🎉 ممنون که پرسیدی. کاری هست که بتونم برات انجام بدم؟",
    ],

    "ممنون": [
        "خواهش می‌کنم! 🙏 خوشحالم که تونستم کمک کنم.",
        "قابلی نداشت! 😊 اگر سوال دیگه‌ای داشتی، بپرس.",
    ],

    "خداحافظ": [
        "خداحافظ! 👋 موفق باشی. هر وقت سوالی داشتی برگرد!",
        "به امید دیدار! 🌟 موفقیت در تحصیلت آرزوی منه.",
    ],

    # ═══════════════════════════════════════════════════════
    # ویزا و مهاجرت
    # ═══════════════════════════════════════════════════════

    "ویزا": [
        "📋 <b>ویزای تحصیلی ایتالیا - راهنمای کامل</b>\n\n"
        "🔹 <b>مدارک اصلی مورد نیاز:</b>\n"
        "• پذیرش دانشگاه (Lettera di ammissione)\n"
        "• مدرک زبان (انگلیسی B2 یا ایتالیایی B1)\n"
        "• تمکن مالی (~۶۵۰۰ یورو در حساب)\n"
        "• بیمه درمانی معتبر\n"
        "• گذرنامه با حداقل ۱۸ ماه اعتبار\n\n"
        "🔹 <b>مراحل:</b>\n"
        "۱. دریافت پذیرش\n"
        "۲. ترجمه و تایید مدارک\n"
        "۳. رزرو وقت سفارت\n"
        "۴. مصاحبه و ارائه مدارک\n"
        "۵. انتظار ۲-۴ هفته‌ای\n\n"
        "💡 برای جزئیات کامل از بخش «راهنما» استفاده کن.",
    ],

    "پرمسو": [
        "🛂 <b>پرمسو دی سوجورنو (Permesso di Soggiorno)</b>\n\n"
        "اجازه اقامت در ایتالیا که بدون آن نمی‌توانید قانونی بمانید!\n\n"
        "⚠️ <b>مهم:</b> ظرف ۸ روز پس از ورود باید اقدام کنی!\n\n"
        "🔹 <b>مراحل:</b>\n"
        "۱. اداره پست (Poste Italiane) → دریافت کیت زرد\n"
        "۲. پر کردن فرم‌ها + کپی مدارک\n"
        "۳. خرید تمبر ۱۶ یورویی از Tabacchi\n"
        "۴. ارسال پاکت در پست\n"
        "۵. انتظار پیامک از Questura\n"
        "۶. مراجعه برای انگشت‌نگاری\n\n"
        "💰 <b>هزینه:</b> حدود ۱۳۰-۱۵۰ یورو\n\n"
        "📖 جزئیات کامل در بخش «راهنما» موجوده.",
    ],

    "کدیچه": [
        "🔢 <b>کدیچه فیسکاله (Codice Fiscale)</b>\n\n"
        "کد ملی ایتالیایی - برای همه کارها لازمه!\n\n"
        "📍 <b>کجا؟</b> Agenzia delle Entrate\n"
        "📄 <b>مدارک:</b> پاسپورت + ویزا (اصل و کپی)\n"
        "💰 <b>هزینه:</b> کاملاً رایگان\n"
        "⏰ <b>زمان:</b> ۱۰-۱۵ دقیقه\n\n"
        "💡 <b>نکته:</b> حتماً از قبل نوبت آنلاین بگیر!\n"
        "🌐 سایت رزرو: agenziaentrate.gov.it",
    ],

    "کوئستورا": [
        "👮 <b>کوئستورا (Questura) - اداره مهاجرت</b>\n\n"
        "📍 <b>آدرس پروجا:</b>\n"
        "Via del Tabacchificio, 21 - Ellera\n\n"
        "🚌 <b>دسترسی:</b> اتوبوس خط G یا قطار\n\n"
        "🔹 <b>کارهای مهم:</b>\n"
        "• انگشت‌نگاری پرمسو\n"
        "• تمدید اقامت\n"
        "• دریافت کارت اقامت\n\n"
        "⏰ <b>ساعت کاری:</b> ۸:۳۰ - ۱۲:۳۰ (فقط صبح‌ها)\n\n"
        "💡 همیشه زودتر برو چون صف طولانیه!",
    ],

    # ═══════════════════════════════════════════════════════
    # هزینه‌ها و مالی
    # ═══════════════════════════════════════════════════════

    "هزینه": [
        "💰 <b>هزینه‌های ماهانه زندگی در پروجا (۲۰۲۵)</b>\n\n"
        "🏠 <b>اجاره:</b>\n"
        "• اتاق مشترک: ۲۸۰-۳۵۰€\n"
        "• اتاق تک‌نفره: ۳۵۰-۴۵۰€\n"
        "• آپارتمان کامل: ۵۵۰-۸۰۰€\n\n"
        "🍽 <b>غذا:</b>\n"
        "• پخت خانگی: ۱۵۰-۲۰۰€\n"
        "• سلف دانشگاه: ۴-۶€ هر وعده\n"
        "• رستوران: ۱۵-۲۵€\n\n"
        "🚌 <b>حمل‌ونقل:</b> ۲۵-۳۵€ (بلیط ماهانه)\n"
        "📱 <b>موبایل:</b> ۱۰-۱۵€ (Iliad)\n"
        "💡 <b>قبوض:</b> ۵۰-۸۰€ (برق/گاز/آب)\n\n"
        "━━━━━━━━━━━━━━━━━━\n"
        "📊 <b>جمع کل:</b> ۶۵۰-۹۰۰€ ماهانه\n\n"
        "🎓 با بورسیه DSU می‌تونه تا ۴۰۰€ کمتر بشه!",
    ],

    "شهریه": [
        "🎓 <b>شهریه دانشگاه پروجا (۲۰۲۵)</b>\n\n"
        "شهریه بر اساس عدد ISEE تعیین می‌شه:\n\n"
        "🟢 <b>ISEE < 27,000€:</b>\n"
        "• شهریه: تقریباً رایگان! (فقط ۱۵۶€ ثبت‌نام)\n"
        "• احتمال بورسیه کامل\n\n"
        "🟡 <b>ISEE 27,000-40,000€:</b>\n"
        "• شهریه: ۵۰۰-۱۵۰۰€\n"
        "• تخفیف جزئی\n\n"
        "🔴 <b>ISEE > 40,000€:</b>\n"
        "• شهریه کامل: ۱۵۰۰-۳۰۰۰€\n\n"
        "💡 <b>نکته مهم:</b>\n"
        "عدد ISEE خودت رو از بخش «ISEE» ربات محاسبه کن!",
    ],

    "isee": [
        "🧮 <b>ISEE چیست؟</b>\n\n"
        "ISEE = شاخص وضعیت اقتصادی خانواده\n\n"
        "این عدد تعیین می‌کنه:\n"
        "• چقدر شهریه بدی\n"
        "• آیا بورسیه بگیری\n"
        "• آیا خوابگاه بهت بدن\n\n"
        "🔹 <b>فرمول ساده:</b>\n"
        "درآمد + ۲۰٪ دارایی ÷ ضریب خانواده\n\n"
        "💡 <b>برای محاسبه دقیق:</b>\n"
        "از بخش «ISEE» در منوی اصلی ربات استفاده کن!\n\n"
        "⚠️ <b>نکته:</b>\n"
        "ISEE رسمی فقط توسط CAF در ایتالیا صادر می‌شه.",
    ],

    # ═══════════════════════════════════════════════════════
    # بورسیه
    # ═══════════════════════════════════════════════════════

    "بورسیه": [
        "🏆 <b>بورسیه DSU (ADISU Umbria)</b>\n\n"
        "مهم‌ترین بورسیه برای دانشجویان خارجی!\n\n"
        "✅ <b>شرایط اصلی:</b>\n"
        "• ISEE زیر ۲۷,۰۰۰ یورو\n"
        "• کسب حداقل ۴۰ واحد در سال\n"
        "• ثبت‌نام فعال در دانشگاه\n\n"
        "🎁 <b>مزایا:</b>\n"
        "• کمک هزینه نقدی: ~۵۰۰۰-۷۰۰۰€ در سال\n"
        "• خوابگاه رایگان\n"
        "• کارت غذای رایگان (Mensa)\n"
        "• معافیت از شهریه\n\n"
        "📅 <b>ددلاین:</b> معمولاً آگوست-سپتامبر\n\n"
        "🌐 <b>سایت:</b> adisumbria.it",
    ],

    # ═══════════════════════════════════════════════════════
    # مسکن و خوابگاه
    # ═══════════════════════════════════════════════════════

    "خوابگاه": [
        "🏠 <b>خوابگاه‌های دانشجویی ADISU</b>\n\n"
        "📍 <b>خوابگاه‌های پروجا:</b>\n"
        "• Via Pascoli (نزدیک مرکز)\n"
        "• Elce (نزدیک دانشکده‌ها)\n"
        "• Monteluce\n\n"
        "💰 <b>هزینه:</b>\n"
        "• با بورسیه: رایگان\n"
        "• بدون بورسیه: ~۲۵۰-۳۵۰€/ماه\n\n"
        "🔹 <b>امکانات:</b>\n"
        "• اینترنت رایگان\n"
        "• آشپزخانه مشترک\n"
        "• لباسشویی\n\n"
        "⚠️ <b>نکته:</b> زود اپلای کن چون جا محدوده!",
    ],

    "اجاره": [
        "🏡 <b>راهنمای اجاره خانه در پروجا</b>\n\n"
        "📍 <b>محله‌های پیشنهادی:</b>\n"
        "• Centro Storico (گرون ولی عالی)\n"
        "• Elce (نزدیک مهندسی)\n"
        "• Fontivegge (نزدیک ایستگاه)\n"
        "• Via dei Filosofi\n\n"
        "💰 <b>قیمت‌ها:</b>\n"
        "• اتاق: ۳۰۰-۴۵۰€\n"
        "• استودیو: ۴۵۰-۶۰۰€\n"
        "• آپارتمان ۲ خوابه: ۶۰۰-۸۰۰€\n\n"
        "🔹 <b>سایت‌های جستجو:</b>\n"
        "• idealista.it\n"
        "• immobiliare.it\n"
        "• subito.it\n"
        "• گروه‌های تلگرام دانشجویان\n\n"
        "⚠️ <b>هشدار:</b>\n"
        "حتماً قرارداد رسمی (contratto) بخواه!",
    ],

    # ═══════════════════════════════════════════════════════
    # زبان ایتالیایی
    # ═══════════════════════════════════════════════════════

    "ایتالیایی": [
        "🇮🇹 <b>یادگیری زبان ایتالیایی</b>\n\n"
        "📚 <b>منابع رایگان:</b>\n"
        "• Duolingo (اپ موبایل)\n"
        "• Babbel\n"
        "• YouTube: Learn Italian with Lucrezia\n"
        "• کلاس‌های رایگان دانشگاه پروجا\n\n"
        "🎓 <b>مدارک رسمی:</b>\n"
        "• CILS (دانشگاه سیه‌نا)\n"
        "• CELI (دانشگاه پروجا)\n"
        "• PLIDA\n\n"
        "💡 <b>نکته:</b>\n"
        "برای تمرین، از بخش «ایتالیایی» ربات استفاده کن!\n"
        "فلش‌کارت، آزمون و تلفظ صوتی داره.",
    ],

    # ═══════════════════════════════════════════════════════
    # دانشگاه
    # ═══════════════════════════════════════════════════════

    "دانشگاه": [
        "🏛 <b>دانشگاه پروجا (Università degli Studi di Perugia)</b>\n\n"
        "یکی از قدیمی‌ترین دانشگاه‌های جهان (تاسیس ۱۳۰۸)!\n\n"
        "🔹 <b>دانشکده‌های اصلی:</b>\n"
        "• مهندسی (Ingegneria)\n"
        "• پزشکی (Medicina)\n"
        "• اقتصاد (Economia)\n"
        "• حقوق (Giurisprudenza)\n"
        "• علوم انسانی (Lettere)\n\n"
        "📍 <b>کمپوس‌ها:</b>\n"
        "• مرکز شهر (Piazza Università)\n"
        "• Sant'Andrea delle Fratte (مهندسی/پزشکی)\n\n"
        "🌐 <b>پرتال:</b> unipg.it\n"
        "📧 <b>ایمیل:</b> international@unipg.it",
    ],

    "ثبت نام": [
        "📝 <b>ثبت‌نام دانشگاه (Immatricolazione)</b>\n\n"
        "🔹 <b>مراحل:</b>\n"
        "۱. ثبت‌نام آنلاین در پرتال SOL\n"
        "۲. آپلود مدارک\n"
        "۳. پرداخت هزینه اولیه (۱۵۶€ + ۱۶€ تمبر)\n"
        "۴. مراجعه حضوری برای تایید\n\n"
        "📄 <b>مدارک:</b>\n"
        "• پذیرش دانشگاه\n"
        "• مدرک زبان\n"
        "• پاسپورت + ویزا\n"
        "• کدیچه فیسکاله\n"
        "• عکس پرسنلی\n\n"
        "🌐 <b>پرتال:</b> unipg.esse3.cineca.it",
    ],

    # ═══════════════════════════════════════════════════════
    # حمل و نقل
    # ═══════════════════════════════════════════════════════

    "اتوبوس": [
        "🚌 <b>حمل‌ونقل عمومی پروجا</b>\n\n"
        "🔹 <b>شرکت:</b> Busitalia\n\n"
        "💰 <b>قیمت بلیط:</b>\n"
        "• تک‌سفره: ۱.۵۰€\n"
        "• ماهانه دانشجویی: ۲۵-۳۵€\n"
        "• سالانه دانشجویی: ~۲۰۰€\n\n"
        "📱 <b>اپلیکیشن:</b>\n"
        "• Salgo (خرید بلیط)\n"
        "• Moovit (مسیریابی)\n\n"
        "🚊 <b>مینی‌مترو:</b>\n"
        "خط اتوماتیک از Pincetto به ایستگاه قطار\n"
        "بلیط: ۱.۵۰€",
    ],

    "قطار": [
        "🚂 <b>قطار در ایتالیا</b>\n\n"
        "🔹 <b>شرکت‌ها:</b>\n"
        "• Trenitalia (اصلی)\n"
        "• Italo (سریع‌السیر)\n\n"
        "📍 <b>ایستگاه پروجا:</b>\n"
        "Perugia Fontivegge (اصلی)\n"
        "Perugia Sant'Anna\n\n"
        "💰 <b>تخفیف دانشجویی:</b>\n"
        "• Carta Verde (زیر ۲۶ سال): ۲۰٪ تخفیف\n"
        "• قیمت: ۴۰€ سالانه\n\n"
        "📱 <b>اپ:</b> Trenitalia\n"
        "🌐 <b>سایت:</b> trenitalia.com",
    ],

    # ═══════════════════════════════════════════════════════
    # غذا و رستوران
    # ═══════════════════════════════════════════════════════

    "غذا": [
        "🍝 <b>غذا خوردن در پروجا</b>\n\n"
        "🏫 <b>سلف دانشگاه (Mensa):</b>\n"
        "• با بورسیه: رایگان\n"
        "• بدون بورسیه: ۴-۶€\n"
        "• مکان‌ها: Via Pascoli, Elce\n\n"
        "🛒 <b>سوپرمارکت‌های ارزان:</b>\n"
        "• Lidl\n"
        "• Eurospin\n"
        "• Conad\n"
        "• Penny Market\n\n"
        "🍕 <b>غذای ایتالیایی:</b>\n"
        "• پیتزا: ۵-۸€\n"
        "• پاستا: ۷-۱۲€\n"
        "• ساندویچ (Panino): ۳-۵€",
    ],

    "حلال": [
        "🥩 <b>غذای حلال در پروجا</b>\n\n"
        "🏪 <b>قصابی و مغازه حلال:</b>\n"
        "• Macelleria Islamica (Via del Macello)\n"
        "• چند مغازه در منطقه Fontivegge\n\n"
        "🍽 <b>رستوران حلال:</b>\n"
        "• رستوران‌های کباب ترکی\n"
        "• برخی رستوران‌های عربی\n\n"
        "💡 <b>نکته:</b>\n"
        "• غذاهای دریایی و گیاهی در همه‌جا موجوده\n"
        "• پاستا با سس سبزیجات حلاله",
    ],

    # ═══════════════════════════════════════════════════════
    # سلامت و پزشکی
    # ═══════════════════════════════════════════════════════

    "بیمه": [
        "🏥 <b>بیمه درمانی در ایتالیا</b>\n\n"
        "📋 <b>نوع ۱: SSN (رایگان)</b>\n"
        "• برای دانشجویان با پرمسو\n"
        "• ثبت‌نام در ASL\n"
        "• پوشش کامل پزشکی\n\n"
        "📋 <b>نوع ۲: بیمه خصوصی</b>\n"
        "• برای ویزا لازمه\n"
        "• شرکت‌ها: INA Assitalia, Generali\n"
        "• هزینه: ۱۰۰-۲۰۰€ سالانه\n\n"
        "💡 <b>پیشنهاد:</b>\n"
        "اول با بیمه خصوصی بیا، بعد SSN بگیر.",
    ],

    "دکتر": [
        "👨‍⚕️ <b>پزشک و درمان در پروجا</b>\n\n"
        "🏥 <b>اورژانس:</b> ۱۱۸\n\n"
        "👨‍⚕️ <b>پزشک خانواده (Medico di Base):</b>\n"
        "• بعد از SSN انتخاب می‌کنی\n"
        "• ویزیت رایگان\n\n"
        "🏨 <b>بیمارستان اصلی:</b>\n"
        "Ospedale Santa Maria della Misericordia\n"
        "📍 Piazzale Menghini, 1\n\n"
        "💊 <b>داروخانه (Farmacia):</b>\n"
        "• با نسخه: یارانه‌ای\n"
        "• بدون نسخه: قیمت کامل",
    ],

    # ═══════════════════════════════════════════════════════
    # سوالات متفرقه
    # ═══════════════════════════════════════════════════════

    "کار": [
        "💼 <b>کار دانشجویی در ایتالیا</b>\n\n"
        "⏰ <b>محدودیت ساعت:</b>\n"
        "حداکثر ۲۰ ساعت در هفته\n\n"
        "💰 <b>حداقل دستمزد:</b>\n"
        "~۸-۱۰€ در ساعت\n\n"
        "🔹 <b>کارهای رایج:</b>\n"
        "• کار در رستوران/کافه\n"
        "• تدریس خصوصی زبان\n"
        "• کار در دانشگاه (tutoring)\n"
        "• Babysitting\n\n"
        "⚠️ <b>نکته:</b>\n"
        "حتماً قرارداد رسمی داشته باش (contratto)",
    ],

    "سیم کارت": [
        "📱 <b>سیم کارت در ایتالیا</b>\n\n"
        "🔹 <b>اپراتورهای ارزان:</b>\n"
        "• Iliad: ۷.۹۹€/ماه (پیشنهادی)\n"
        "• ho. Mobile: ۶.۹۹€/ماه\n"
        "• Kena Mobile\n\n"
        "📄 <b>مدارک لازم:</b>\n"
        "• پاسپورت\n"
        "• کدیچه فیسکاله\n\n"
        "💡 <b>نکته:</b>\n"
        "Iliad در تمام Tabacchi فروخته می‌شه.",
    ],

    "بانک": [
        "🏦 <b>افتتاح حساب بانکی</b>\n\n"
        "🔹 <b>بانک‌های پیشنهادی:</b>\n"
        "• Intesa Sanpaolo (شعبه زیاد)\n"
        "• UniCredit\n"
        "• N26 (آنلاین، آسان)\n"
        "• Revolut (اپ)\n\n"
        "📄 <b>مدارک:</b>\n"
        "• پاسپورت\n"
        "• کدیچه فیسکاله\n"
        "• پرمسو یا رسید آن\n"
        "• مدرک سکونت\n\n"
        "💰 <b>هزینه:</b>\n"
        "• حساب دانشجویی معمولاً رایگانه",
    ],

    # ═══════════════════════════════════════════════════════
    # پاسخ پیش‌فرض
    # ═══════════════════════════════════════════════════════

    "default": [
        "🤔 سوال جالبیه!\n\n"
        "متأسفانه الان پاسخ دقیقی ندارم.\n\n"
        "💡 <b>پیشنهاد:</b>\n"
        "• از منوی اصلی گزینه مورد نظر رو انتخاب کن\n"
        "• یا از بخش «پشتیبانی» تیکت بزن\n\n"
        "ادمین‌ها در اسرع وقت پاسخ می‌دن! 🙏",
        
        "🔍 متوجه سوالت شدم!\n\n"
        "برای پاسخ دقیق‌تر، پیشنهاد می‌کنم:\n"
        "• 📖 بخش راهنما رو ببین\n"
        "• 💰 بخش ISEE رو چک کن\n"
        "• 🎧 یه تیکت پشتیبانی بزن\n\n"
        "حتماً کمکت می‌کنیم! 💪",
        
        "🌟 ممنون از سوالت!\n\n"
        "این موضوع نیاز به بررسی بیشتر داره.\n"
        "لطفاً از بخش «پشتیبانی» تیکت بزن تا ادمین‌ها راهنماییت کنن.",
    ],
}


# ═══════════════════════════════════════════════════════════════════════════════
# ۱۱. دیکشنری ایتالیایی-فارسی (برای Fallback ترجمه)
# ═══════════════════════════════════════════════════════════════════════════════

ITALIAN_PERSIAN_DICTIONARY: Dict[str, str] = {

    # ═══════════════════════════════════════════════════════
    # اصطلاحات اداری و مهاجرتی
    # ═══════════════════════════════════════════════════════

    "permesso di soggiorno": "اجازه اقامت (پرمسو)",
    "carta di soggiorno": "کارت اقامت",
    "codice fiscale": "کد مالیاتی (مثل کد ملی)",
    "questura": "اداره پلیس/مهاجرت",
    "prefettura": "فرمانداری",
    "comune": "شهرداری",
    "anagrafe": "اداره ثبت احوال",
    "agenzia delle entrate": "اداره مالیات",
    "sportello": "باجه/گیشه",
    "appuntamento": "وقت ملاقات/نوبت",
    "prenotazione": "رزرو/نوبت‌گیری",
    "rinnovo": "تمدید",
    "scadenza": "تاریخ انقضا",
    "proroga": "تمدید موقت",
    "ricevuta": "رسید",
    "marca da bollo": "تمبر مالیاتی",
    "modulo": "فرم",
    "domanda": "درخواست",
    "richiesta": "درخواست",
    "documenti": "مدارک",
    "fotocopia": "فتوکپی",
    "originale": "اصل",
    "traduzione giurata": "ترجمه رسمی (با مهر)",
    "apostille": "تاییدیه لاهه",
    "dichiarazione di valore": "تاییدیه ارزش مدرک",
    "legalizzazione": "تایید قانونی",

    # ═══════════════════════════════════════════════════════
    # دانشگاه و تحصیل
    # ═══════════════════════════════════════════════════════

    "università": "دانشگاه",
    "facoltà": "دانشکده",
    "dipartimento": "گروه/دپارتمان",
    "corso di laurea": "رشته تحصیلی",
    "laurea triennale": "لیسانس (۳ ساله)",
    "laurea magistrale": "کارشناسی ارشد",
    "dottorato": "دکتری",
    "master": "مستر/فوق لیسانس",
    "immatricolazione": "ثبت‌نام اولیه",
    "iscrizione": "ثبت‌نام",
    "tasse universitarie": "شهریه دانشگاه",
    "contributi": "شهریه/هزینه‌ها",
    "esonero": "معافیت",
    "borsa di studio": "بورسیه تحصیلی",
    "esame": "امتحان",
    "voto": "نمره",
    "crediti": "واحد درسی (CFU)",
    "piano di studi": "چارت درسی",
    "lezione": "کلاس/درس",
    "seminario": "سمینار",
    "laboratorio": "آزمایشگاه",
    "tirocinio": "کارآموزی",
    "tesi": "پایان‌نامه",
    "relatore": "استاد راهنما",
    "correlatore": "استاد مشاور",
    "sessione": "ترم امتحانات",
    "appello": "نوبت امتحان",
    "segreteria studenti": "دفتر امور دانشجویی",
    "biblioteca": "کتابخانه",
    "aula": "کلاس درس",
    "mensa": "سلف/غذاخوری",
    "studentato": "خوابگاه",
    "residenza universitaria": "خوابگاه دانشجویی",
    "professore": "استاد",
    "docente": "مدرس",
    "studente": "دانشجو",
    "matricola": "شماره دانشجویی",
    "libretto": "کارنامه دانشجویی",
    "attestato": "گواهی",
    "certificato": "گواهینامه",
    "diploma": "دیپلم/مدرک",

    # ═══════════════════════════════════════════════════════
    # مسکن و اجاره
    # ═══════════════════════════════════════════════════════

    "affitto": "اجاره",
    "contratto": "قرارداد",
    "contratto di affitto": "قرارداد اجاره",
    "caparra": "ودیعه/بیعانه",
    "deposito": "ودیعه",
    "cauzione": "ضمانت",
    "mensilità": "اجاره ماهانه",
    "spese": "هزینه‌ها",
    "bollette": "قبوض",
    "utenze": "آب و برق و گاز",
    "riscaldamento": "گرمایش",
    "condominio": "هزینه ساختمان",
    "inquilino": "مستاجر",
    "coinquilino": "هم‌خانه",
    "padrone di casa": "صاحب‌خانه",
    "proprietario": "مالک",
    "agenzia immobiliare": "آژانس املاک",
    "appartamento": "آپارتمان",
    "monolocale": "استودیو",
    "bilocale": "آپارتمان ۱ خوابه",
    "trilocale": "آپارتمان ۲ خوابه",
    "stanza": "اتاق",
    "camera": "اتاق خواب",
    "bagno": "حمام/دستشویی",
    "cucina": "آشپزخانه",
    "soggiorno": "نشیمن",
    "balcone": "بالکن",
    "terrazzo": "تراس",
    "cantina": "زیرزمین/انباری",
    "garage": "پارکینگ",
    "ascensore": "آسانسور",
    "piano": "طبقه",
    "arredato": "مبله",
    "non arredato": "بدون مبل",
    "disdetta": "فسخ قرارداد",
    "preavviso": "اعلام قبلی",

    # ═══════════════════════════════════════════════════════
    # بهداشت و پزشکی
    # ═══════════════════════════════════════════════════════

    "assicurazione sanitaria": "بیمه درمانی",
    "tessera sanitaria": "کارت بهداشت",
    "medico di base": "پزشک خانواده",
    "medico di medicina generale": "پزشک عمومی",
    "pronto soccorso": "اورژانس",
    "ospedale": "بیمارستان",
    "clinica": "کلینیک",
    "ambulatorio": "مطب/درمانگاه",
    "farmacia": "داروخانه",
    "ricetta": "نسخه",
    "visita medica": "ویزیت پزشکی",
    "analisi": "آزمایش",
    "esami del sangue": "آزمایش خون",
    "vaccino": "واکسن",
    "certificato medico": "گواهی پزشکی",

    # ═══════════════════════════════════════════════════════
    # بانک و مالی
    # ═══════════════════════════════════════════════════════

    "banca": "بانک",
    "conto corrente": "حساب جاری",
    "conto bancario": "حساب بانکی",
    "carta di credito": "کارت اعتباری",
    "carta di debito": "کارت نقدی",
    "bancomat": "کارت عابر بانک",
    "bonifico": "حواله/انتقال وجه",
    "versamento": "واریز",
    "prelievo": "برداشت",
    "estratto conto": "صورت‌حساب",
    "iban": "شماره شبا بانکی",
    "filiale": "شعبه",

    # ═══════════════════════════════════════════════════════
    # عبارات روزمره
    # ═══════════════════════════════════════════════════════

    "buongiorno": "صبح بخیر / روز بخیر",
    "buonasera": "عصر بخیر",
    "buonanotte": "شب بخیر",
    "ciao": "سلام / خداحافظ",
    "salve": "سلام (رسمی)",
    "arrivederci": "خداحافظ (رسمی)",
    "grazie": "ممنون",
    "grazie mille": "خیلی ممنون",
    "prego": "خواهش می‌کنم",
    "scusa": "ببخشید (غیررسمی)",
    "scusi": "ببخشید (رسمی)",
    "mi scusi": "عذر می‌خوام",
    "per favore": "لطفاً",
    "per piacere": "لطفاً",
    "sì": "بله",
    "no": "نه",
    "forse": "شاید",
    "va bene": "باشه / خوبه",
    "d'accordo": "موافقم",
    "non capisco": "نمی‌فهمم",
    "non parlo italiano": "ایتالیایی بلد نیستم",
    "parla inglese?": "انگلیسی صحبت می‌کنید؟",
    "come si dice?": "چطور می‌گن؟",
    "che cosa significa?": "یعنی چی؟",
    "quanto costa?": "قیمتش چنده؟",
    "dov'è?": "کجاست؟",
    "quando?": "کی؟",
    "come?": "چطور؟",
    "perché?": "چرا؟",
    "chi?": "کی؟ (چه کسی)",
    "cosa?": "چی؟",
    "quale?": "کدوم؟",

    # ═══════════════════════════════════════════════════════
    # اعداد
    # ═══════════════════════════════════════════════════════

    "uno": "یک",
    "due": "دو",
    "tre": "سه",
    "quattro": "چهار",
    "cinque": "پنج",
    "sei": "شش",
    "sette": "هفت",
    "otto": "هشت",
    "nove": "نه",
    "dieci": "ده",
    "undici": "یازده",
    "dodici": "دوازده",
    "tredici": "سیزده",
    "quattordici": "چهارده",
    "quindici": "پانزده",
    "sedici": "شانزده",
    "diciassette": "هفده",
    "diciotto": "هجده",
    "diciannove": "نوزده",
    "venti": "بیست",
    "trenta": "سی",
    "quaranta": "چهل",
    "cinquanta": "پنجاه",
    "sessanta": "شصت",
    "settanta": "هفتاد",
    "ottanta": "هشتاد",
    "novanta": "نود",
    "cento": "صد",
    "mille": "هزار",
    "un milione": "یک میلیون",

    # ═══════════════════════════════════════════════════════
    # روزها و ماه‌ها
    # ═══════════════════════════════════════════════════════

    "lunedì": "دوشنبه",
    "martedì": "سه‌شنبه",
    "mercoledì": "چهارشنبه",
    "giovedì": "پنج‌شنبه",
    "venerdì": "جمعه",
    "sabato": "شنبه",
    "domenica": "یک‌شنبه",
    "gennaio": "ژانویه",
    "febbraio": "فوریه",
    "marzo": "مارس",
    "aprile": "آوریل",
    "maggio": "مه",
    "giugno": "ژوئن",
    "luglio": "ژوئیه",
    "agosto": "اوت",
    "settembre": "سپتامبر",
    "ottobre": "اکتبر",
    "novembre": "نوامبر",
    "dicembre": "دسامبر",
    "oggi": "امروز",
    "domani": "فردا",
    "ieri": "دیروز",
    "settimana": "هفته",
    "mese": "ماه",
    "anno": "سال",

    # ═══════════════════════════════════════════════════════
    # مکان‌ها
    # ═══════════════════════════════════════════════════════

    "stazione": "ایستگاه",
    "aeroporto": "فرودگاه",
    "fermata": "ایستگاه (اتوبوس)",
    "centro": "مرکز شهر",
    "piazza": "میدان",
    "via": "خیابان",
    "strada": "جاده",
    "supermercato": "سوپرمارکت",
    "negozio": "مغازه",
    "ristorante": "رستوران",
    "bar": "کافه",
    "pizzeria": "پیتزا فروشی",
    "chiesa": "کلیسا",
    "museo": "موزه",
    "parco": "پارک",
    "piscina": "استخر",
    "palestra": "باشگاه ورزشی",
    "ufficio postale": "اداره پست",
    "tabacchi": "تنباکوفروشی (برای تمبر و بلیط)",

    # ═══════════════════════════════════════════════════════
    # غذا و نوشیدنی
    # ═══════════════════════════════════════════════════════

    "acqua": "آب",
    "vino": "شراب",
    "birra": "آبجو",
    "caffè": "قهوه",
    "tè": "چای",
    "latte": "شیر",
    "pane": "نان",
    "pasta": "پاستا",
    "pizza": "پیتزا",
    "carne": "گوشت",
    "pesce": "ماهی",
    "pollo": "مرغ",
    "verdura": "سبزیجات",
    "frutta": "میوه",
    "formaggio": "پنیر",
    "uova": "تخم‌مرغ",
    "riso": "برنج",
    "insalata": "سالاد",
    "dolce": "شیرینی/دسر",
    "gelato": "بستنی",
    "colazione": "صبحانه",
    "pranzo": "ناهار",
    "cena": "شام",
    "il conto": "صورتحساب",

    # ═══════════════════════════════════════════════════════
    # صفات کاربردی
    # ═══════════════════════════════════════════════════════

    "buono": "خوب",
    "cattivo": "بد",
    "grande": "بزرگ",
    "piccolo": "کوچک",
    "caldo": "گرم",
    "freddo": "سرد",
    "nuovo": "جدید",
    "vecchio": "قدیمی",
    "aperto": "باز",
    "chiuso": "بسته",
    "libero": "آزاد/خالی",
    "occupato": "اشغال",
    "caro": "گران",
    "economico": "ارزان",
    "facile": "آسان",
    "difficile": "سخت",
    "vicino": "نزدیک",
    "lontano": "دور",
    "pronto": "آماده",
    "urgente": "فوری",
}


# ═══════════════════════════════════════════════════════════════════════════════
# پایان بخش ۲ - ادامه در بخش ۳
# ═══════════════════════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════════════════════
# ۱۲. کلاس اصلی AIService
# ═══════════════════════════════════════════════════════════════════════════════

class AIService:
    """
    سرویس هوش مصنوعی چندمدله با پشتیبانی از OpenRouter.ai
    
    این کلاس قابلیت‌های زیر را فراهم می‌کند:
    
    1. چت با AI (پشتیبانی از چندین مدل)
    2. ترجمه متن (ایتالیایی/انگلیسی ↔ فارسی)
    3. خلاصه‌سازی متن
    4. کمک در یادگیری زبان ایتالیایی
    5. پاسخ هوشمند به تیکت‌های پشتیبانی
    
    ویژگی‌های کلیدی:
    - Fallback چندلایه: اگر یک مدل fail شد، مدل بعدی امتحان می‌شود
    - کش هوشمند: پاسخ‌های تکراری از کش برمی‌گردند
    - اطلاع‌رسانی به ادمین: در صورت خطای مهم
    - پاسخ آماده: اگر همه مدل‌ها fail شدند
    
    نحوه استفاده:
        from services.ai_service import ai_service
        
        response = await ai_service.chat("سوال من")
        translation = await ai_service.translate("Buongiorno", source="it")
    """
    
    def __init__(self):
        """
        مقداردهی اولیه سرویس
        
        API Key از settings خوانده می‌شود:
        settings.OPENROUTER_API_KEY
        """
        
        # ═══════════════════════════════════════════════════
        # خواندن API Key
        # ═══════════════════════════════════════════════════
        
        # اول چک می‌کنیم OPENROUTER_API_KEY وجود دارد
        self.api_key: Optional[str] = getattr(settings, 'OPENROUTER_API_KEY', None)
        
        # اگر نبود، از HUGGINGFACE_API_KEY استفاده می‌کنیم (سازگاری با قبل)
        if not self.api_key:
            self.api_key = getattr(settings, 'HUGGINGFACE_API_KEY', None)
        
        # ═══════════════════════════════════════════════════
        # تنظیم وضعیت اولیه
        # ═══════════════════════════════════════════════════
        
        if self.api_key and len(self.api_key) > 10:
            self.status = AIStatus.ONLINE
            logger.success(f"🤖 AI Service initialized with API Key")
        else:
            self.status = AIStatus.OFFLINE
            logger.warning("⚠️ AI Service initialized WITHOUT API Key - Fallback mode only")
        
        # ═══════════════════════════════════════════════════
        # ساخت هدرها
        # ═══════════════════════════════════════════════════
        
        self.headers: Dict[str, str] = get_openrouter_headers(self.api_key) if self.api_key else {}
        
        # ═══════════════════════════════════════════════════
        # آمار مصرف
        # ═══════════════════════════════════════════════════
        
        self.usage_stats = APIUsageStats()
        
        # بارگذاری آمار قبلی (اگر وجود داشت)
        self._load_stats()
        
        # ═══════════════════════════════════════════════════
        # کش
        # ═══════════════════════════════════════════════════
        
        # کش در حافظه
        self._cache: Dict[str, CacheEntry] = {}
        
        # مدت اعتبار کش
        self._cache_ttl = timedelta(hours=CACHE_TTL_HOURS)
        
        # ═══════════════════════════════════════════════════
        # وضعیت مدل‌ها
        # ═══════════════════════════════════════════════════
        
        # لیست مدل‌هایی که موقتاً غیرفعال شده‌اند (به دلیل خطا)
        self._disabled_models: Dict[str, datetime] = {}
        
        # مدت زمان غیرفعال بودن یک مدل پس از خطا (دقیقه)
        self._model_cooldown_minutes: int = 5
        
        # ═══════════════════════════════════════════════════
        # Reference به bot برای ارسال پیام به ادمین
        # ═══════════════════════════════════════════════════
        
        self._bot = None  # بعداً توسط main.py تنظیم می‌شود
        
        # ═══════════════════════════════════════════════════
        # لاگ
        # ═══════════════════════════════════════════════════
        
        logger.info(f"📊 AI Service Status: {self.status.value}")
        logger.info(f"📊 Available Models: {len(AVAILABLE_MODELS)}")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۳. متدهای مدیریت وضعیت
    # ═══════════════════════════════════════════════════════════════════════════
    
    def set_bot(self, bot) -> None:
        """
        تنظیم reference به bot برای ارسال پیام به ادمین
        
        این متد توسط main.py فراخوانی می‌شود:
            ai_service.set_bot(bot)
        """
        self._bot = bot
        logger.debug("🤖 Bot reference set for AI Service")
    
    def is_available(self) -> bool:
        """
        آیا سرویس AI در دسترس است؟
        
        Returns:
            True اگر حداقل یک روش پاسخ‌دهی موجود باشد
        """
        # حتی اگر API نداشته باشیم، Fallback داریم
        return True
    
    def is_ai_available(self) -> bool:
        """
        آیا AI واقعی (نه Fallback) در دسترس است؟
        
        Returns:
            True اگر API Key داشته باشیم و Online باشیم
        """
        return (
            self.status in [AIStatus.ONLINE, AIStatus.DEGRADED] 
            and bool(self.api_key)
        )
    
    def get_status(self) -> Dict[str, Any]:
        """
        دریافت وضعیت کامل سرویس
        
        Returns:
            دیکشنری شامل تمام اطلاعات وضعیت
        """
        
        # محاسبه نرخ موفقیت
        total = self.usage_stats.total_requests
        if total > 0:
            success_rate = (self.usage_stats.successful_requests / total) * 100
        else:
            success_rate = 0.0
        
        # تعداد مدل‌های فعال
        active_models = len([
            m for m in AVAILABLE_MODELS 
            if m not in self._disabled_models
        ])
        
        return {
            "status": self.status.value,
            "api_key_configured": bool(self.api_key),
            "total_requests": total,
            "successful_requests": self.usage_stats.successful_requests,
            "failed_requests": self.usage_stats.failed_requests,
            "fallback_used": self.usage_stats.fallback_used,
            "success_rate": f"{success_rate:.1f}%",
            "total_models": len(AVAILABLE_MODELS),
            "active_models": active_models,
            "disabled_models": list(self._disabled_models.keys()),
            "cache_size": len(self._cache),
            "last_error": self.usage_stats.last_error,
            "last_error_model": self.usage_stats.last_error_model,
            "last_successful": self.usage_stats.last_successful_request.isoformat() 
                if self.usage_stats.last_successful_request else None,
        }
    
    def get_available_models(self) -> List[Dict[str, Any]]:
        """
        لیست مدل‌های موجود و وضعیت آن‌ها
        
        Returns:
            لیست دیکشنری‌ها با اطلاعات هر مدل
        """
        
        result = []
        now = datetime.now()
        
        for key, model in AVAILABLE_MODELS.items():
            
            # آیا موقتاً غیرفعال است؟
            is_disabled = key in self._disabled_models
            disabled_until = None
            
            if is_disabled:
                disabled_until = self._disabled_models[key]
                # اگر زمان گذشته، فعال کن
                if now > disabled_until:
                    del self._disabled_models[key]
                    is_disabled = False
            
            result.append({
                "key": key,
                "name": model.display_name,
                "provider": model.provider,
                "priority": model.priority,
                "is_active": model.is_active and not is_disabled,
                "disabled_until": disabled_until.isoformat() if disabled_until else None,
                "requests": self.usage_stats.requests_per_model.get(key, 0),
            })
        
        # مرتب‌سازی بر اساس اولویت
        result.sort(key=lambda x: x["priority"])
        
        return result
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۴. متدهای کش
    # ═══════════════════════════════════════════════════════════════════════════
    
    def _make_cache_key(self, text: str, task_type: str = "chat") -> str:
        """
        ساخت کلید یکتا برای کش
        
        Args:
            text: متن ورودی
            task_type: نوع کار (chat, translate, etc.)
        
        Returns:
            هش MD5 به عنوان کلید
        """
        
        # نرمال‌سازی متن
        normalized = text.lower().strip()
        
        # ترکیب با نوع کار
        combined = f"{task_type}:{normalized}"
        
        # ساخت هش
        return hashlib.md5(combined.encode('utf-8')).hexdigest()
    
    def _get_from_cache(self, key: str) -> Optional[CacheEntry]:
        """
        دریافت از کش (اگر معتبر باشد)
        
        Args:
            key: کلید کش
        
        Returns:
            CacheEntry اگر پیدا شد و معتبر بود، وگرنه None
        """
        
        if key not in self._cache:
            return None
        
        entry = self._cache[key]
        
        # چک اعتبار زمانی
        if datetime.now() - entry.timestamp > self._cache_ttl:
            # منقضی شده - حذف
            del self._cache[key]
            return None
        
        # افزایش شمارنده استفاده
        entry.hit_count += 1
        
        logger.debug(f"📦 Cache HIT for key {key[:8]}... (hits: {entry.hit_count})")
        
        return entry
    
    def _save_to_cache(
        self, 
        key: str, 
        response: str, 
        source: str,
        model_used: Optional[str] = None
    ) -> None:
        """
        ذخیره در کش
        
        Args:
            key: کلید کش
            response: پاسخ برای ذخیره
            source: منبع پاسخ ("ai" یا "fallback")
            model_used: مدل استفاده شده
        """
        
        # چک حداکثر سایز کش
        if len(self._cache) >= MAX_CACHE_SIZE:
            # حذف قدیمی‌ترین ورودی
            self._cleanup_cache()
        
        # ذخیره
        self._cache[key] = CacheEntry(
            response=response,
            timestamp=datetime.now(),
            source=source,
            model_used=model_used,
            hit_count=0,
        )
        
        logger.debug(f"📦 Cache SAVE for key {key[:8]}... (source: {source})")
    
    def _cleanup_cache(self) -> None:
        """
        پاکسازی کش - حذف ورودی‌های قدیمی و کم‌استفاده
        """
        
        if not self._cache:
            return
        
        now = datetime.now()
        
        # ابتدا ورودی‌های منقضی را حذف کن
        expired_keys = [
            key for key, entry in self._cache.items()
            if now - entry.timestamp > self._cache_ttl
        ]
        
        for key in expired_keys:
            del self._cache[key]
        
        # اگر هنوز پر است، کم‌استفاده‌ترین‌ها را حذف کن
        if len(self._cache) >= MAX_CACHE_SIZE:
            # مرتب‌سازی بر اساس hit_count و timestamp
            sorted_items = sorted(
                self._cache.items(),
                key=lambda x: (x[1].hit_count, x[1].timestamp)
            )
            
            # حذف ۲۰٪ کم‌استفاده‌ترین‌ها
            to_remove = len(sorted_items) // 5
            for key, _ in sorted_items[:to_remove]:
                del self._cache[key]
        
        logger.info(f"🧹 Cache cleanup: {len(expired_keys)} expired, size now: {len(self._cache)}")
    
    def clear_cache(self) -> int:
        """
        پاکسازی کامل کش
        
        Returns:
            تعداد ورودی‌های حذف شده
        """
        
        count = len(self._cache)
        self._cache.clear()
        logger.info(f"🗑️ Cache cleared: {count} entries removed")
        return count
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۵. متد اصلی فراخوانی OpenRouter API
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def _call_openrouter(
        self,
        model_key: str,
        messages: List[Dict[str, str]],
        max_tokens: int = 1024,
        temperature: float = 0.7,
    ) -> Optional[str]:
        """
        فراخوانی OpenRouter API با یک مدل مشخص
        
        Args:
            model_key: کلید مدل (مثلاً "gpt-4o-mini")
            messages: لیست پیام‌ها در فرمت OpenAI
            max_tokens: حداکثر توکن خروجی
            temperature: میزان خلاقیت (0-1)
        
        Returns:
            متن پاسخ یا None در صورت خطا
        
        Raises:
            هیچ Exception ای raise نمی‌شود - خطاها لاگ می‌شوند
        """
        
        # ═══════════════════════════════════════════════════
        # اعتبارسنجی
        # ═══════════════════════════════════════════════════
        
        if not self.api_key:
            logger.warning("❌ No API key available")
            return None
        
        if model_key not in AVAILABLE_MODELS:
            logger.error(f"❌ Unknown model: {model_key}")
            return None
        
        model = AVAILABLE_MODELS[model_key]
        
        # چک آیا مدل موقتاً غیرفعال است
        if model_key in self._disabled_models:
            if datetime.now() < self._disabled_models[model_key]:
                logger.debug(f"⏸️ Model {model_key} is temporarily disabled")
                return None
            else:
                # زمان گذشته - فعال کن
                del self._disabled_models[model_key]
        
        # ═══════════════════════════════════════════════════
        # ساخت درخواست
        # ═══════════════════════════════════════════════════
        
        payload = {
            "model": model.model_id,
            "messages": messages,
            "max_tokens": min(max_tokens, model.max_tokens),
            "temperature": temperature,
        }
        
        # ═══════════════════════════════════════════════════
        # ارسال درخواست با Retry
        # ═══════════════════════════════════════════════════
        
        for attempt in range(MAX_RETRIES_PER_MODEL):
            
            try:
                logger.debug(f"🔄 Calling {model.display_name} (attempt {attempt + 1})")
                
                async with httpx.AsyncClient(
                    timeout=httpx.Timeout(
                        REQUEST_TIMEOUT_SECONDS,
                        connect=CONNECTION_TIMEOUT_SECONDS
                    )
                ) as client:
                    
                    response = await client.post(
                        OPENROUTER_BASE_URL,
                        headers=self.headers,
                        json=payload,
                    )
                    
                    # ═══════════════════════════════════════
                    # پردازش پاسخ موفق
                    # ═══════════════════════════════════════
                    
                    if response.status_code == 200:
                        
                        data = response.json()
                        
                        # استخراج متن پاسخ
                        if "choices" in data and len(data["choices"]) > 0:
                            content = data["choices"][0].get("message", {}).get("content", "")
                            
                            if content:
                                # ثبت آمار
                                self.usage_stats.successful_requests += 1
                                self.usage_stats.last_successful_request = datetime.now()
                                
                                if model_key not in self.usage_stats.requests_per_model:
                                    self.usage_stats.requests_per_model[model_key] = 0
                                self.usage_stats.requests_per_model[model_key] += 1
                                
                                # تخمین توکن مصرفی
                                self.usage_stats.total_tokens_used += len(content.split()) * 2
                                
                                logger.success(f"✅ {model.display_name} responded successfully")
                                
                                return content.strip()
                        
                        logger.warning(f"⚠️ Empty response from {model.display_name}")
                        return None
                    
                    # ═══════════════════════════════════════
                    # مدیریت خطاهای HTTP
                    # ═══════════════════════════════════════
                    
                    elif response.status_code == 429:
                        # Rate limit - غیرفعال کردن موقت
                        logger.warning(f"⚠️ Rate limited by {model.display_name}")
                        self._disable_model_temporarily(model_key, minutes=10)
                        return None
                    
                    elif response.status_code == 401:
                        # API Key نامعتبر
                        logger.error("❌ Invalid API Key")
                        self.status = AIStatus.OFFLINE
                        await self._notify_admin_error("API Key نامعتبر است!")
                        return None
                    
                    elif response.status_code == 402:
                        # اعتبار تمام شده
                        logger.error("❌ Insufficient credits")
                        await self._notify_admin_error("اعتبار API تمام شده!")
                        return None
                    
                    elif response.status_code == 503:
                        # سرویس موقتاً در دسترس نیست
                        logger.warning(f"⚠️ {model.display_name} temporarily unavailable")
                        if attempt < MAX_RETRIES_PER_MODEL - 1:
                            await asyncio.sleep(RETRY_DELAY_SECONDS * (attempt + 1))
                            continue
                        return None
                    
                    else:
                        # سایر خطاها
                        error_text = response.text[:200] if response.text else "Unknown error"
                        logger.error(f"❌ API Error {response.status_code}: {error_text}")
                        
                        self.usage_stats.last_error = f"HTTP {response.status_code}"
                        self.usage_stats.last_error_time = datetime.now()
                        self.usage_stats.last_error_model = model_key
                        
                        return None
            
            # ═══════════════════════════════════════════════════
            # مدیریت Exception ها
            # ═══════════════════════════════════════════════════
            
            except httpx.TimeoutException:
                logger.warning(f"⏱️ Timeout calling {model.display_name} (attempt {attempt + 1})")
                
                if attempt < MAX_RETRIES_PER_MODEL - 1:
                    await asyncio.sleep(RETRY_DELAY_SECONDS)
                    continue
                
                self.usage_stats.last_error = "Timeout"
                self.usage_stats.last_error_time = datetime.now()
                self.usage_stats.last_error_model = model_key
                
            except httpx.ConnectError as e:
                logger.error(f"🔌 Connection error to {model.display_name}: {e}")
                
                self.usage_stats.last_error = "Connection Error"
                self.usage_stats.last_error_time = datetime.now()
                
                # غیرفعال کردن موقت
                self._disable_model_temporarily(model_key, minutes=2)
                return None
                
            except Exception as e:
                logger.error(f"❌ Unexpected error calling {model.display_name}: {e}")
                
                self.usage_stats.last_error = str(e)
                self.usage_stats.last_error_time = datetime.now()
                self.usage_stats.last_error_model = model_key
                return None
        
        # همه تلاش‌ها شکست خورد
        self.usage_stats.failed_requests += 1
        return None
    
    def _disable_model_temporarily(self, model_key: str, minutes: int = 5) -> None:
        """
        غیرفعال کردن موقت یک مدل
        
        Args:
            model_key: کلید مدل
            minutes: مدت غیرفعالی به دقیقه
        """
        
        until = datetime.now() + timedelta(minutes=minutes)
        self._disabled_models[model_key] = until
        
        logger.info(f"⏸️ Model {model_key} disabled until {until.strftime('%H:%M:%S')}")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۶. متد فراخوانی با Fallback چندلایه
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def _call_with_fallback(
        self,
        messages: List[Dict[str, str]],
        model_priority: List[str],
        max_tokens: int = 1024,
        temperature: float = 0.7,
    ) -> Tuple[Optional[str], Optional[str]]:
        """
        فراخوانی API با سیستم Fallback چندلایه
        
        اگر مدل اول fail شد، مدل دوم امتحان می‌شود و الی آخر.
        
        Args:
            messages: لیست پیام‌ها
            model_priority: لیست مدل‌ها به ترتیب اولویت
            max_tokens: حداکثر توکن خروجی
            temperature: میزان خلاقیت
        
        Returns:
            Tuple[پاسخ یا None, کلید مدل استفاده شده یا None]
        """
        
        if not self.is_ai_available():
            logger.debug("🔌 AI not available, skipping API calls")
            return None, None
        
        # امتحان کردن مدل‌ها به ترتیب اولویت
        for model_key in model_priority:
            
            # چک آیا مدل وجود دارد و فعال است
            if model_key not in AVAILABLE_MODELS:
                continue
            
            if not AVAILABLE_MODELS[model_key].is_active:
                continue
            
            # فراخوانی API
            response = await self._call_openrouter(
                model_key=model_key,
                messages=messages,
                max_tokens=max_tokens,
                temperature=temperature,
            )
            
            if response:
                return response, model_key
            
            # این مدل fail شد، مدل بعدی
            logger.debug(f"🔄 {model_key} failed, trying next model...")
        
        # همه مدل‌ها fail شدند
        logger.warning("⚠️ All models failed")
        return None, None
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۷. اطلاع‌رسانی به ادمین
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def _notify_admin_error(self, error_message: str) -> None:
        """
        ارسال پیام خطا به ادمین‌ها
        
        Args:
            error_message: متن خطا
        """
        
        if not self._bot:
            logger.warning("Cannot notify admin: Bot not set")
            return
        
        text = (
            "🚨 <b>هشدار سرویس AI</b>\n\n"
            f"⚠️ {error_message}\n\n"
            f"⏰ زمان: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"📊 وضعیت: {self.status.value}"
        )
        
        for admin_id in settings.ADMIN_CHAT_IDS:
            try:
                await self._bot.send_message(
                    chat_id=admin_id,
                    text=text,
                    parse_mode="HTML"
                )
            except Exception as e:
                logger.error(f"Failed to notify admin {admin_id}: {e}")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۸. ذخیره و بارگذاری آمار
    # ═══════════════════════════════════════════════════════════════════════════
    
    def _load_stats(self) -> None:
        """بارگذاری آمار از فایل"""
        
        if not STATS_FILE.exists():
            return
        
        try:
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            self.usage_stats.total_requests = data.get("total_requests", 0)
            self.usage_stats.successful_requests = data.get("successful_requests", 0)
            self.usage_stats.failed_requests = data.get("failed_requests", 0)
            self.usage_stats.fallback_used = data.get("fallback_used", 0)
            self.usage_stats.total_tokens_used = data.get("total_tokens_used", 0)
            self.usage_stats.requests_per_model = data.get("requests_per_model", {})
            
            logger.info("📊 Stats loaded from file")
            
        except Exception as e:
            logger.warning(f"Could not load stats: {e}")
    
    def save_stats(self) -> None:
        """ذخیره آمار در فایل"""
        
        # اطمینان از وجود پوشه
        STATS_FILE.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            data = {
                "total_requests": self.usage_stats.total_requests,
                "successful_requests": self.usage_stats.successful_requests,
                "failed_requests": self.usage_stats.failed_requests,
                "fallback_used": self.usage_stats.fallback_used,
                "total_tokens_used": self.usage_stats.total_tokens_used,
                "requests_per_model": self.usage_stats.requests_per_model,
                "last_saved": datetime.now().isoformat(),
            }
            
            with open(STATS_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            logger.debug("📊 Stats saved to file")
            
        except Exception as e:
            logger.error(f"Could not save stats: {e}")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۱۹. متد کمکی پیدا کردن پاسخ Fallback
    # ═══════════════════════════════════════════════════════════════════════════
    
    def _get_fallback_response(self, message: str) -> str:
        """
        پیدا کردن پاسخ مناسب از دیتابیس Fallback
        
        Args:
            message: پیام نرمال‌شده (lowercase)
        
        Returns:
            پاسخ مناسب
        """
        
        # جستجوی کلیدواژه در پیام
        for keyword, responses in FALLBACK_RESPONSES.items():
            if keyword != "default" and keyword in message:
                return random.choice(responses)
        
        # پاسخ پیش‌فرض
        return random.choice(FALLBACK_RESPONSES["default"])


# ═══════════════════════════════════════════════════════════════════════════════
# پایان بخش ۳ - ادامه در بخش ۴
# ═══════════════════════════════════════════════════════════════════════════════
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۰. متد اصلی چت
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def chat(
        self,
        message: str,
        user_id: int = 0,
        context: str = "student_assistant",
        use_cache: bool = True,
    ) -> AIResponse:
        """
        چت با هوش مصنوعی
        
        این متد اصلی‌ترین متد سرویس است و برای پاسخ به سوالات کاربران استفاده می‌شود.
        
        Args:
            message: پیام کاربر
            user_id: شناسه کاربر (برای لاگ)
            context: نوع مکالمه (student_assistant, support, etc.)
            use_cache: آیا از کش استفاده شود؟
        
        Returns:
            AIResponse شامل پاسخ و اطلاعات اضافی
        
        مثال:
            response = await ai_service.chat("شرایط بورسیه چیه؟")
            print(response.text)
            print(f"AI: {response.is_ai_generated}, Model: {response.model_used}")
        """
        
        start_time = time.time()
        
        # ═══════════════════════════════════════════════════
        # ۱. افزایش شمارنده
        # ═══════════════════════════════════════════════════
        
        self.usage_stats.total_requests += 1
        
        # ═══════════════════════════════════════════════════
        # ۲. نرمال‌سازی پیام
        # ═══════════════════════════════════════════════════
        
        message_clean = message.strip()
        message_lower = message_clean.lower()
        
        if not message_clean:
            return AIResponse(
                text="لطفاً سوالت رو بنویس! 😊",
                is_ai_generated=False,
                is_fallback=True,
                processing_time_ms=0,
            )
        
        # ═══════════════════════════════════════════════════
        # ۳. چک کش
        # ═══════════════════════════════════════════════════
        
        cache_key = None
        if use_cache:
            cache_key = self._make_cache_key(message_lower, "chat")
            cached = self._get_from_cache(cache_key)
            
            if cached:
                processing_time = int((time.time() - start_time) * 1000)
                
                return AIResponse(
                    text=cached.response,
                    is_ai_generated=(cached.source == "ai"),
                    model_used=cached.model_used,
                    from_cache=True,
                    is_fallback=(cached.source == "fallback"),
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۴. تلاش برای API
        # ═══════════════════════════════════════════════════
        
        if self.is_ai_available():
            
            # ساخت پیام‌ها برای API
            system_prompt = SYSTEM_PROMPTS.get(context, SYSTEM_PROMPTS["student_assistant"])
            
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message_clean},
            ]
            
            # فراخوانی با Fallback
            response_text, model_used = await self._call_with_fallback(
                messages=messages,
                model_priority=CHAT_MODEL_PRIORITY,
                max_tokens=1024,
                temperature=0.7,
            )
            
            if response_text:
                processing_time = int((time.time() - start_time) * 1000)
                
                # ذخیره در کش
                if use_cache and cache_key:
                    self._save_to_cache(cache_key, response_text, "ai", model_used)
                
                # پیدا کردن اطلاعات مدل
                provider = None
                display_name = None
                if model_used and model_used in AVAILABLE_MODELS:
                    provider = AVAILABLE_MODELS[model_used].provider
                    display_name = AVAILABLE_MODELS[model_used].display_name
                
                return AIResponse(
                    text=response_text,
                    is_ai_generated=True,
                    model_used=display_name or model_used,
                    provider=provider,
                    from_cache=False,
                    is_fallback=False,
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۵. Fallback به پاسخ‌های آماده
        # ═══════════════════════════════════════════════════
        
        self.usage_stats.fallback_used += 1
        
        fallback_response = self._get_fallback_response(message_lower)
        
        processing_time = int((time.time() - start_time) * 1000)
        
        # ذخیره در کش
        if use_cache and cache_key:
            self._save_to_cache(cache_key, fallback_response, "fallback", None)
        
        return AIResponse(
            text=fallback_response,
            is_ai_generated=False,
            model_used=None,
            provider=None,
            from_cache=False,
            is_fallback=True,
            processing_time_ms=processing_time,
        )
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۱. متد ترجمه
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def translate(
        self,
        text: str,
        source_lang: str = "it",
        target_lang: str = "fa",
        use_cache: bool = True,
    ) -> AIResponse:
        """
        ترجمه متن
        
        Args:
            text: متن برای ترجمه
            source_lang: زبان مبدأ (it, en, fa)
            target_lang: زبان مقصد (it, en, fa)
            use_cache: استفاده از کش
        
        Returns:
            AIResponse شامل ترجمه
        
        مثال:
            result = await ai_service.translate("Buongiorno", source_lang="it")
            print(result.text)  # صبح بخیر
        """
        
        start_time = time.time()
        
        self.usage_stats.total_requests += 1
        
        text_clean = text.strip()
        text_lower = text_clean.lower()
        
        if not text_clean:
            return AIResponse(
                text="متنی برای ترجمه وارد نشده!",
                is_ai_generated=False,
                is_fallback=True,
                processing_time_ms=0,
            )
        
        # ═══════════════════════════════════════════════════
        # ۱. چک دیکشنری محلی
        # ═══════════════════════════════════════════════════
        
        if source_lang == "it" and target_lang == "fa":
            # چک دقیق
            if text_lower in ITALIAN_PERSIAN_DICTIONARY:
                translation = ITALIAN_PERSIAN_DICTIONARY[text_lower]
                processing_time = int((time.time() - start_time) * 1000)
                
                return AIResponse(
                    text=f"🇮🇹 <b>{text_clean}</b>\n\n🇮🇷 {translation}",
                    is_ai_generated=False,
                    is_fallback=True,
                    processing_time_ms=processing_time,
                )
            
            # چک جزئی - جایگزینی کلمات شناخته‌شده
            modified_text = text_lower
            found_translations = []
            
            for term, translation in ITALIAN_PERSIAN_DICTIONARY.items():
                if term in modified_text:
                    modified_text = modified_text.replace(term, f"«{translation}»")
                    found_translations.append(f"{term} = {translation}")
            
            if found_translations:
                processing_time = int((time.time() - start_time) * 1000)
                
                result_text = f"🔤 <b>متن اصلی:</b>\n{text_clean}\n\n"
                result_text += f"📝 <b>با ترجمه جزئی:</b>\n{modified_text}\n\n"
                result_text += "📖 <b>کلمات شناسایی‌شده:</b>\n"
                result_text += "\n".join([f"• {t}" for t in found_translations[:10]])
                
                return AIResponse(
                    text=result_text,
                    is_ai_generated=False,
                    is_fallback=True,
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۲. چک کش
        # ═══════════════════════════════════════════════════
        
        cache_key = None
        if use_cache:
            cache_key = self._make_cache_key(f"{source_lang}>{target_lang}:{text_lower}", "translate")
            cached = self._get_from_cache(cache_key)
            
            if cached:
                processing_time = int((time.time() - start_time) * 1000)
                return AIResponse(
                    text=cached.response,
                    is_ai_generated=(cached.source == "ai"),
                    model_used=cached.model_used,
                    from_cache=True,
                    is_fallback=(cached.source == "fallback"),
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۳. ترجمه با API
        # ═══════════════════════════════════════════════════
        
        if self.is_ai_available():
            
            # ساخت پرامپت ترجمه
            lang_names = {
                "it": "ایتالیایی",
                "en": "انگلیسی",
                "fa": "فارسی",
            }
            
            source_name = lang_names.get(source_lang, source_lang)
            target_name = lang_names.get(target_lang, target_lang)
            
            messages = [
                {
                    "role": "system", 
                    "content": SYSTEM_PROMPTS["translator"]
                },
                {
                    "role": "user", 
                    "content": f"این متن را از {source_name} به {target_name} ترجمه کن:\n\n{text_clean}"
                },
            ]
            
            response_text, model_used = await self._call_with_fallback(
                messages=messages,
                model_priority=TRANSLATION_MODEL_PRIORITY,
                max_tokens=1024,
                temperature=0.3,  # دقت بیشتر
            )
            
            if response_text:
                processing_time = int((time.time() - start_time) * 1000)
                
                # فرمت زیبا
                formatted = f"🌐 <b>ترجمه:</b>\n\n"
                formatted += f"📝 <b>متن اصلی ({source_name}):</b>\n{text_clean}\n\n"
                formatted += f"📖 <b>ترجمه ({target_name}):</b>\n{response_text}"
                
                if use_cache and cache_key:
                    self._save_to_cache(cache_key, formatted, "ai", model_used)
                
                provider = None
                display_name = None
                if model_used and model_used in AVAILABLE_MODELS:
                    provider = AVAILABLE_MODELS[model_used].provider
                    display_name = AVAILABLE_MODELS[model_used].display_name
                
                return AIResponse(
                    text=formatted,
                    is_ai_generated=True,
                    model_used=display_name,
                    provider=provider,
                    from_cache=False,
                    is_fallback=False,
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۴. Fallback
        # ═══════════════════════════════════════════════════
        
        self.usage_stats.fallback_used += 1
        processing_time = int((time.time() - start_time) * 1000)
        
        fallback_text = (
            f"🔤 <b>متن:</b>\n{text_clean}\n\n"
            "❌ ترجمه خودکار در دسترس نیست.\n\n"
            "💡 <b>پیشنهاد:</b>\n"
            "• از Google Translate استفاده کن\n"
            "• یا WordReference.com"
        )
        
        return AIResponse(
            text=fallback_text,
            is_ai_generated=False,
            is_fallback=True,
            processing_time_ms=processing_time,
        )
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۲. متد خلاصه‌سازی
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def summarize(
        self,
        text: str,
        max_length: int = 200,
    ) -> AIResponse:
        """
        خلاصه‌سازی متن
        
        Args:
            text: متن برای خلاصه
            max_length: حداکثر طول خلاصه (تعداد کلمه)
        
        Returns:
            AIResponse شامل خلاصه
        """
        
        start_time = time.time()
        
        self.usage_stats.total_requests += 1
        
        text_clean = text.strip()
        
        if not text_clean:
            return AIResponse(
                text="متنی برای خلاصه‌سازی وارد نشده!",
                is_ai_generated=False,
                is_fallback=True,
                processing_time_ms=0,
            )
        
        # ═══════════════════════════════════════════════════
        # ۱. API
        # ═══════════════════════════════════════════════════
        
        if self.is_ai_available():
            
            messages = [
                {
                    "role": "system",
                    "content": SYSTEM_PROMPTS["summarizer"]
                },
                {
                    "role": "user",
                    "content": f"این متن را در حداکثر {max_length} کلمه خلاصه کن:\n\n{text_clean}"
                },
            ]
            
            response_text, model_used = await self._call_with_fallback(
                messages=messages,
                model_priority=SUMMARIZATION_MODEL_PRIORITY,
                max_tokens=512,
                temperature=0.3,
            )
            
            if response_text:
                processing_time = int((time.time() - start_time) * 1000)
                
                provider = None
                display_name = None
                if model_used and model_used in AVAILABLE_MODELS:
                    provider = AVAILABLE_MODELS[model_used].provider
                    display_name = AVAILABLE_MODELS[model_used].display_name
                
                return AIResponse(
                    text=response_text,
                    is_ai_generated=True,
                    model_used=display_name,
                    provider=provider,
                    is_fallback=False,
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۲. Fallback ساده
        # ═══════════════════════════════════════════════════
        
        self.usage_stats.fallback_used += 1
        
        # خلاصه‌سازی ساده: ۳ جمله اول
        sentences = text_clean.replace('\n', ' ').split('.')
        summary = '. '.join(s.strip() for s in sentences[:3] if s.strip())
        if summary and not summary.endswith('.'):
            summary += '.'
        
        if not summary:
            summary = text_clean[:200] + "..."
        
        processing_time = int((time.time() - start_time) * 1000)
        
        return AIResponse(
            text=summary,
            is_ai_generated=False,
            is_fallback=True,
            processing_time_ms=processing_time,
        )
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۳. متد کمک ایتالیایی
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def italian_helper(
        self,
        word: str,
        help_type: str = "meaning",
    ) -> AIResponse:
        """
        کمک در یادگیری زبان ایتالیایی
        
        Args:
            word: کلمه یا عبارت ایتالیایی
            help_type: نوع کمک
                - "meaning": معنی و توضیح
                - "example": جمله مثال
                - "conjugate": صرف فعل
                - "pronunciation": تلفظ
        
        Returns:
            AIResponse
        """
        
        start_time = time.time()
        
        self.usage_stats.total_requests += 1
        
        word_clean = word.strip()
        word_lower = word_clean.lower()
        
        if not word_clean:
            return AIResponse(
                text="کلمه‌ای وارد نشده!",
                is_ai_generated=False,
                is_fallback=True,
                processing_time_ms=0,
            )
        
        # ═══════════════════════════════════════════════════
        # ۱. چک دیکشنری محلی
        # ═══════════════════════════════════════════════════
        
        if help_type == "meaning" and word_lower in ITALIAN_PERSIAN_DICTIONARY:
            meaning = ITALIAN_PERSIAN_DICTIONARY[word_lower]
            processing_time = int((time.time() - start_time) * 1000)
            
            return AIResponse(
                text=f"🇮🇹 <b>{word_clean}</b>\n\n🇮🇷 <b>معنی:</b> {meaning}",
                is_ai_generated=False,
                is_fallback=True,
                processing_time_ms=processing_time,
            )
        
        # ═══════════════════════════════════════════════════
        # ۲. API
        # ═══════════════════════════════════════════════════
        
        if self.is_ai_available():
            
            prompts = {
                "meaning": f"معنی و توضیح کلمه ایتالیایی «{word_clean}» را به فارسی بگو. تلفظ را هم با فینگلیش بنویس.",
                "example": f"برای کلمه ایتالیایی «{word_clean}» سه جمله مثال کاربردی بزن با ترجمه فارسی.",
                "conjugate": f"فعل ایتالیایی «{word_clean}» را در زمان حال (presente) صرف کن: io, tu, lui/lei, noi, voi, loro",
                "pronunciation": f"تلفظ صحیح کلمه ایتالیایی «{word_clean}» را با فینگلیش فارسی بنویس و نکات تلفظی را توضیح بده.",
            }
            
            prompt = prompts.get(help_type, prompts["meaning"])
            
            messages = [
                {"role": "system", "content": SYSTEM_PROMPTS["italian_teacher"]},
                {"role": "user", "content": prompt},
            ]
            
            response_text, model_used = await self._call_with_fallback(
                messages=messages,
                model_priority=CHAT_MODEL_PRIORITY,
                max_tokens=512,
                temperature=0.5,
            )
            
            if response_text:
                processing_time = int((time.time() - start_time) * 1000)
                
                provider = None
                display_name = None
                if model_used and model_used in AVAILABLE_MODELS:
                    provider = AVAILABLE_MODELS[model_used].provider
                    display_name = AVAILABLE_MODELS[model_used].display_name
                
                return AIResponse(
                    text=response_text,
                    is_ai_generated=True,
                    model_used=display_name,
                    provider=provider,
                    is_fallback=False,
                    processing_time_ms=processing_time,
                )
        
        # ═══════════════════════════════════════════════════
        # ۳. Fallback
        # ═══════════════════════════════════════════════════
        
        self.usage_stats.fallback_used += 1
        processing_time = int((time.time() - start_time) * 1000)
        
        fallback_text = (
            f"🇮🇹 <b>{word_clean}</b>\n\n"
            "❌ اطلاعات این کلمه در دیتابیس نیست.\n\n"
            "💡 <b>پیشنهاد:</b>\n"
            "• WordReference.com\n"
            "• Google Translate\n"
            "• Reverso Context"
        )
        
        return AIResponse(
            text=fallback_text,
            is_ai_generated=False,
            is_fallback=True,
            processing_time_ms=processing_time,
        )
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۴. متد پاسخ هوشمند پشتیبانی
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def smart_support(
        self,
        ticket_message: str,
        user_name: str = "کاربر",
    ) -> Tuple[str, float]:
        """
        پاسخ هوشمند به تیکت پشتیبانی
        
        این متد برای کمک به ادمین‌ها در پاسخ‌دهی سریع‌تر استفاده می‌شود.
        
        Args:
            ticket_message: متن تیکت
            user_name: نام کاربر
        
        Returns:
            Tuple[پاسخ پیشنهادی, میزان اطمینان (0-1)]
        """
        
        message_lower = ticket_message.lower()
        
        # ═══════════════════════════════════════════════════
        # ۱. جستجوی کلیدواژه
        # ═══════════════════════════════════════════════════
        
        for keyword, responses in FALLBACK_RESPONSES.items():
            if keyword != "default" and keyword in message_lower:
                return random.choice(responses), 0.8
        
        # ═══════════════════════════════════════════════════
        # ۲. API
        # ═══════════════════════════════════════════════════
        
        if self.is_ai_available():
            response = await self.chat(
                message=ticket_message,
                context="support_agent",
                use_cache=False,  # پاسخ‌های پشتیبانی نباید کش شوند
            )
            
            if response.is_ai_generated:
                return response.text, 0.7
        
        # ═══════════════════════════════════════════════════
        # ۳. Fallback
        # ═══════════════════════════════════════════════════
        
        return random.choice(FALLBACK_RESPONSES["default"]), 0.3
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۵. متد توصیه آب‌وهوا
    # ═══════════════════════════════════════════════════════════════════════════
    
    def get_weather_advice(
        self,
        temperature: float,
        condition: str,
    ) -> str:
        """
        توصیه هوشمند بر اساس آب‌وهوا
        
        Args:
            temperature: دما به سلسیوس
            condition: وضعیت آب‌وهوا (Clear, Rain, Snow, ...)
        
        Returns:
            متن توصیه
        """
        
        condition_lower = condition.lower()
        
        # ═══════════════════════════════════════════════════
        # ۱. شرایط خاص
        # ═══════════════════════════════════════════════════
        
        if "rain" in condition_lower or "pioggia" in condition_lower or "drizzle" in condition_lower:
            return WEATHER_ADVICE["rainy"]
        
        if "thunder" in condition_lower or "storm" in condition_lower:
            return WEATHER_ADVICE["stormy"]
        
        if "snow" in condition_lower or "neve" in condition_lower:
            return WEATHER_ADVICE["snowy"]
        
        if "fog" in condition_lower or "mist" in condition_lower or "nebbia" in condition_lower:
            return WEATHER_ADVICE["foggy"]
        
        if "wind" in condition_lower or "vento" in condition_lower:
            if temperature < 15:
                return WEATHER_ADVICE["windy"]
        
        if "cloud" in condition_lower or "nuv" in condition_lower:
            return WEATHER_ADVICE["cloudy"]
        
        # ═══════════════════════════════════════════════════
        # ۲. بر اساس دما
        # ═══════════════════════════════════════════════════
        
        if temperature >= 35:
            return WEATHER_ADVICE["hot"]
        elif temperature >= 28:
            return WEATHER_ADVICE["warm"]
        elif temperature >= 20:
            return WEATHER_ADVICE["nice"]
        elif temperature >= 15:
            return WEATHER_ADVICE["mild"]
        elif temperature >= 8:
            return WEATHER_ADVICE["cool"]
        elif temperature >= 0:
            return WEATHER_ADVICE["cold"]
        else:
            return WEATHER_ADVICE["freezing"]
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۶. متد تولید پاسخ ساده (برای سازگاری)
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def generate_response(
        self,
        prompt: str,
        system_prompt: Optional[str] = None,
        max_tokens: int = 1024,
        temperature: float = 0.7,
    ) -> Optional[str]:
        """
        تولید پاسخ ساده (برای سازگاری با کد قدیمی)
        
        Args:
            prompt: متن درخواست
            system_prompt: پرامپت سیستم (اختیاری)
            max_tokens: حداکثر توکن
            temperature: خلاقیت
        
        Returns:
            متن پاسخ یا None
        """
        
        if not system_prompt:
            system_prompt = SYSTEM_PROMPTS["student_assistant"]
        
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": prompt},
        ]
        
        response_text, _ = await self._call_with_fallback(
            messages=messages,
            model_priority=CHAT_MODEL_PRIORITY,
            max_tokens=max_tokens,
            temperature=temperature,
        )
        
        return response_text
    
    # ═══════════════════════════════════════════════════════════════════════════
    # ۲۷. متد بررسی سلامت سرویس
    # ═══════════════════════════════════════════════════════════════════════════
    
    async def health_check(self) -> Dict[str, Any]:
        """
        بررسی سلامت سرویس AI
        
        Returns:
            دیکشنری شامل وضعیت سلامت
        """
        
        result = {
            "status": "unknown",
            "api_available": False,
            "fallback_available": True,
            "cache_working": True,
            "models_checked": 0,
            "working_models": [],
            "failed_models": [],
        }
        
        # چک API
        if self.is_ai_available():
            # تست یک مدل ساده
            test_messages = [
                {"role": "user", "content": "Say 'OK' if you can read this."}
            ]
            
            for model_key in ["gpt-4o-mini", "gemini-flash", "llama-3.1-8b"]:
                if model_key in AVAILABLE_MODELS:
                    result["models_checked"] += 1
                    
                    response = await self._call_openrouter(
                        model_key=model_key,
                        messages=test_messages,
                        max_tokens=10,
                        temperature=0,
                    )
                    
                    if response:
                        result["working_models"].append(model_key)
                        result["api_available"] = True
                    else:
                        result["failed_models"].append(model_key)
        
        # تعیین وضعیت کلی
        if result["api_available"]:
            if len(result["failed_models"]) == 0:
                result["status"] = "healthy"
            else:
                result["status"] = "degraded"
        else:
            result["status"] = "fallback_only"
        
        return result


# ═══════════════════════════════════════════════════════════════════════════════
# ۲۸. ایجاد نمونه Singleton
# ═══════════════════════════════════════════════════════════════════════════════

# نمونه واحد از سرویس که در کل برنامه استفاده می‌شود
ai_service = AIService()


# ═══════════════════════════════════════════════════════════════════════════════
# ۲۹. توابع کمکی برای دسترسی آسان
# ═══════════════════════════════════════════════════════════════════════════════

async def quick_chat(message: str) -> str:
    """
    چت سریع با AI - فقط متن پاسخ را برمی‌گرداند
    
    Args:
        message: پیام کاربر
    
    Returns:
        متن پاسخ
    """
    response = await ai_service.chat(message)
    return response.text


async def quick_translate(text: str, source: str = "it", target: str = "fa") -> str:
    """
    ترجمه سریع - فقط متن ترجمه را برمی‌گرداند
    
    Args:
        text: متن برای ترجمه
        source: زبان مبدأ
        target: زبان مقصد
    
    Returns:
        متن ترجمه شده
    """
    response = await ai_service.translate(text, source, target)
    return response.text


def get_ai_status() -> Dict[str, Any]:
    """
    دریافت وضعیت سرویس AI
    
    Returns:
        دیکشنری وضعیت
    """
    return ai_service.get_status()


# ═══════════════════════════════════════════════════════════════════════════════
# ۳۰. پایان فایل ai_service.py
# ═══════════════════════════════════════════════════════════════════════════════

logger.success("🤖 AI Service fully loaded and ready!")
logger.info(f"   Status: {ai_service.status.value}")
logger.info(f"   Available models: {len(AVAILABLE_MODELS)}")
logger.info(f"   Fallback entries: {len(FALLBACK_RESPONSES)}")
logger.info(f"   Dictionary entries: {len(ITALIAN_PERSIAN_DICTIONARY)}")